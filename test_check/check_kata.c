/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "check_kata_test.c" instead.
 */

#include <check.h>

#line 1 "check_kata_test.c"

#include "../inc/kata.h"

START_TEST(infix_Input1)
{
#line 5
	char rpnOut[MAX_OUTPUT_STRING];
	returnType out = infixToRPN("a+b-c",rpnOut);

	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "abc-+");
	}

}
END_TEST

START_TEST(infix_Input2)
{
#line 16
	char rpnOut[MAX_OUTPUT_STRING];
	returnType out = infixToRPN("(a+b)-c",rpnOut);

	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "ab+c-");
	}

}
END_TEST

START_TEST(infix_Input3)
{
#line 27
	char rpnOut[MAX_OUTPUT_STRING];
	returnType out = infixToRPN("((l/(m^n))*o)-p",rpnOut);

	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "lmn^/o*p-");
	}

}
END_TEST

START_TEST(infix_Input4)
{
#line 38
	char rpnOut[MAX_OUTPUT_STRING];
	returnType out = infixToRPN("((v/w)^x)*(y-z)",rpnOut);

	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "vw/x^yz-*");
	}

}
END_TEST

START_TEST(infix_input5)
{
#line 49
	char rpnOut[MAX_OUTPUT_STRING];
	returnType out = infixToRPN("(a+g)*(((b-a)+c)^(c+(e*(d^f))))",rpnOut);

	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "ag+ba-c+cedf^*+^*");
	}

}
END_TEST

START_TEST(infix_Boundry_Limit_Check)
{
#line 60
	char rpnOut[MAX_OUTPUT_STRING];
	// check input is null
	returnType out = infixToRPN("",rpnOut);

	ck_assert_int_eq(out,ERROR_INPUT_OUT_OF_BOUNDS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}

}
END_TEST

START_TEST(infix_Extra_Start_Brace_Check)
{
#line 72
	char rpnOut[MAX_OUTPUT_STRING];
	returnType out = infixToRPN("b/(f*e-f+(z-y)*k/m",rpnOut);
	
	ck_assert_int_eq(out,ERROR_MISMATCHED_BRACES);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}

}
END_TEST

START_TEST(infix_Extra_End_Brace_Check)
{
#line 83
	char rpnOut[MAX_OUTPUT_STRING];
	returnType out = infixToRPN("b/f*e-f+(z-y)*k/m)",rpnOut);
	
	ck_assert_int_eq(out,ERROR_MISMATCHED_BRACES);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}

}
END_TEST

START_TEST(infix_Incorrect_Brace_Check)
{
#line 94
	char rpnOut[MAX_OUTPUT_STRING];
	returnType out = infixToRPN("b/(f*e-f+(z-)y)*k/m",rpnOut);
	
	ck_assert_int_eq(out,ERROR_MISMATCHED_BRACES);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}

}
END_TEST

START_TEST(infix_Missing_Operator_Check)
{
#line 105
	char rpnOut[MAX_OUTPUT_STRING];
	// check missing operator between a and b and c
	returnType out = infixToRPN("abc+g-f/e-z+y",rpnOut);
	
	ck_assert_int_eq(out,ERROR_INVALID_INPUT_EXPR);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}

}
END_TEST

START_TEST(infix_Extra_Operator_Check)
{
#line 117
	char rpnOut[MAX_OUTPUT_STRING];
	// extra operator - at the end
	returnType out = infixToRPN("a*b-f+(g-h+q)/n+p-",rpnOut);
	
	ck_assert_int_eq(out,ERROR_INVALID_INPUT_EXPR);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}


}
END_TEST

START_TEST(infix_Uppercase_Operand_Check)
{
#line 130
	char rpnOut[MAX_OUTPUT_STRING];
        // Uppercase letters are undefined characters, as only only lowercase letters are valid
	returnType out = infixToRPN("a-b+q/M*n",rpnOut);
	
	ck_assert_int_eq(out,ERROR_UNDEFINED_CHARACTER);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}


}
END_TEST

START_TEST(infix_Undefined_Operand_Check)
{
#line 143
	char rpnOut[MAX_OUTPUT_STRING];
	// undefined character & is present in the input
	returnType out = infixToRPN("vw&x^yz-*",rpnOut);
	
	ck_assert_int_eq(out,ERROR_INVALID_INPUT_EXPR);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}

}
END_TEST

START_TEST(infix_White_Space_Character_Check)
{
#line 155
	char rpnOut[MAX_OUTPUT_STRING];
	// White spaces are considered as undefined character 
	returnType out = infixToRPN("a + b-c",rpnOut);
	
	ck_assert_int_eq(out,ERROR_UNDEFINED_CHARACTER);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(rpnOut, "");
	}

}
END_TEST

START_TEST(rpn_Input1)
{
#line 167
	char infixOut[MAX_OUTPUT_STRING];
	returnType out = RPNToInfix("abc-+",infixOut);
	
	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "a+(b-c)");
	}

}
END_TEST

START_TEST(rpn_Input2)
{
#line 178
	char infixOut[MAX_OUTPUT_STRING];
	returnType out = RPNToInfix("ab+c-",infixOut);
	
	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "(a+b)-c");
	}

}
END_TEST

START_TEST(rpn_Input3)
{
#line 189
	char *infixOut;
	returnType out = RPNToInfix("lmn^/o*p-",infixOut);
	
	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "((l/(m^n))*o)-p");
	}

}
END_TEST

START_TEST(rpn_Input4)
{
#line 200
	char infixOut[MAX_OUTPUT_STRING];
	returnType out = RPNToInfix("vw/x^yz-*",infixOut);
	
	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "((v/w)^x)*(y-z)");
	}

}
END_TEST

START_TEST(rpn_Input5)
{
#line 211
	char infixOut[MAX_OUTPUT_STRING];
	returnType out = RPNToInfix("ag+ba-c+cedf^*+^*",infixOut);
	
	ck_assert_int_eq(out,SUCCESS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "(a+g)*(((b-a)+c)^(c+(e*(d^f))))");
	}

}
END_TEST

START_TEST(rpn_Boundary_Limit_Check)
{
#line 222
	char infixOut[MAX_OUTPUT_STRING];
	// input string is null
	returnType out = RPNToInfix("",infixOut);
	
	ck_assert_int_eq(out,ERROR_INPUT_OUT_OF_BOUNDS);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "");
	}

}
END_TEST

START_TEST(rpn_Input_Brace_Check)
{
#line 234
	char infixOut[MAX_OUTPUT_STRING];
    // Note:rpn input should not contain braces, hence braces are undefined characters
	returnType out = RPNToInfix("lm(n^/o)*p-",infixOut);
	
	ck_assert_int_eq(out,ERROR_UNDEFINED_CHARACTER);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "");
	}

}
END_TEST

START_TEST(rpn_Undefined_Character_Check)
{
#line 246
	char infixOut[MAX_OUTPUT_STRING];
    // Note:Numbers are undefined characters
	returnType out = RPNToInfix("l8n^/o)*p-",infixOut);
	
	ck_assert_int_eq(out,ERROR_UNDEFINED_CHARACTER);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "");
	}

}
END_TEST

START_TEST(rpn_Uppercase_Character_Check)
{
#line 258
	char infixOut[MAX_OUTPUT_STRING];
    // Note:Uppercase charcters are undefined characters. Only lowercase characters are allowed
	returnType out = RPNToInfix("Ab+c-",infixOut);
	
	ck_assert_int_eq(out,ERROR_UNDEFINED_CHARACTER);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "");
	}


}
END_TEST

START_TEST(rpn_Incorrect_Operand_Number_Check)
{
#line 271
	char infixOut[MAX_OUTPUT_STRING];
   // Incorrect number of operands in input expression
	returnType out = RPNToInfix("abcd-*bc/pqm+-",infixOut);
	
	ck_assert_int_eq(out,ERROR_INVALID_INPUT_EXPR);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "");
	}

}
END_TEST

START_TEST(rpn_Incorrect_Operator_Number_Check)
{
#line 283
	char infixOut[MAX_OUTPUT_STRING];
   // Incorrect number of operator in input expression
	returnType out = RPNToInfix("pq+/*-bc/mcm+-",infixOut);
	
	ck_assert_int_eq(out,ERROR_INVALID_INPUT_EXPR);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "");
	}

}
END_TEST

START_TEST(rpn_White_Space_Character_Check)
{
#line 295
	char infixOut[MAX_OUTPUT_STRING];
    // Note:white spaces are undefined characters
	returnType out = RPNToInfix("ab + c-",infixOut);
	
	ck_assert_int_eq(out,ERROR_UNDEFINED_CHARACTER);

	if(out == SUCCESS)
	{
		ck_assert_str_eq(infixOut, "");
	}





}
END_TEST

int main(void)
{
    Suite *s1 = suite_create("Core");
    TCase *tc1_1 = tcase_create("Core");
    SRunner *sr = srunner_create(s1);
    int nf;

    suite_add_tcase(s1, tc1_1);
    tcase_add_test(tc1_1, infix_Input1);
    tcase_add_test(tc1_1, infix_Input2);
    tcase_add_test(tc1_1, infix_Input3);
    tcase_add_test(tc1_1, infix_Input4);
    tcase_add_test(tc1_1, infix_input5);
    tcase_add_test(tc1_1, infix_Boundry_Limit_Check);
    tcase_add_test(tc1_1, infix_Extra_Start_Brace_Check);
    tcase_add_test(tc1_1, infix_Extra_End_Brace_Check);
    tcase_add_test(tc1_1, infix_Incorrect_Brace_Check);
    tcase_add_test(tc1_1, infix_Missing_Operator_Check);
    tcase_add_test(tc1_1, infix_Extra_Operator_Check);
    tcase_add_test(tc1_1, infix_Uppercase_Operand_Check);
    tcase_add_test(tc1_1, infix_Undefined_Operand_Check);
    tcase_add_test(tc1_1, infix_White_Space_Character_Check);
    tcase_add_test(tc1_1, rpn_Input1);
    tcase_add_test(tc1_1, rpn_Input2);
    tcase_add_test(tc1_1, rpn_Input3);
    tcase_add_test(tc1_1, rpn_Input4);
    tcase_add_test(tc1_1, rpn_Input5);
    tcase_add_test(tc1_1, rpn_Boundary_Limit_Check);
    tcase_add_test(tc1_1, rpn_Input_Brace_Check);
    tcase_add_test(tc1_1, rpn_Undefined_Character_Check);
    tcase_add_test(tc1_1, rpn_Uppercase_Character_Check);
    tcase_add_test(tc1_1, rpn_Incorrect_Operand_Number_Check);
    tcase_add_test(tc1_1, rpn_Incorrect_Operator_Number_Check);
    tcase_add_test(tc1_1, rpn_White_Space_Character_Check);

    srunner_run_all(sr, CK_VERBOSE);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);

    return nf == 0 ? 0 : 1;
}
